
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/shalomb/gum/cmd/clone.go (3.3%)</option>
				
				<option value="file1">github.com/shalomb/gum/cmd/dirs-cache.go (5.6%)</option>
				
				<option value="file2">github.com/shalomb/gum/cmd/dirs.go (6.2%)</option>
				
				<option value="file3">github.com/shalomb/gum/cmd/github.go (5.3%)</option>
				
				<option value="file4">github.com/shalomb/gum/cmd/projects.go (86.9%)</option>
				
				<option value="file5">github.com/shalomb/gum/cmd/root.go (40.0%)</option>
				
				<option value="file6">github.com/shalomb/gum/cmd/update.go (23.1%)</option>
				
				<option value="file7">github.com/shalomb/gum/cmd/version.go (50.0%)</option>
				
				<option value="file8">github.com/shalomb/gum/internal/cache/cache.go (85.3%)</option>
				
				<option value="file9">github.com/shalomb/gum/internal/database/database.go (73.7%)</option>
				
				<option value="file10">github.com/shalomb/gum/internal/database/operations.go (85.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/
package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/spf13/cobra"
        "github.com/shalomb/gum/internal/cache"
)

var (
        cloneTarget string
        cloneSuggest bool
)

// cloneCmd represents the clone command
var cloneCmd = &amp;cobra.Command{
        Use:   "clone [repository]",
        Short: "Intelligently clone GitHub repositories",
        Long: `Clone GitHub repositories with intelligent directory suggestions based on existing projects.

This command:
- Analyzes existing project structure
- Suggests optimal clone locations based on similarity
- Handles both full GitHub URLs and org/repo format
- Creates appropriate directory structure

Examples:
  gum clone shalomb/gum
  gum clone https://github.com/shalomb/gum.git
  gum clone --suggest shalomb/gum  # Just suggest, don't clone`,
        Args: cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                repo := args[0]
                
                // Normalize repository format
                normalizedRepo := normalizeRepoURL(repo)
                if normalizedRepo == "" </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid repository format: %s\n", repo)
                        return
                }</span>
                
                // Get existing projects for similarity matching
                <span class="cov0" title="0">existingProjects := getExistingProjects()
                
                // Find best clone location
                suggestions := suggestCloneLocation(normalizedRepo, existingProjects)
                
                if cloneSuggest </span><span class="cov0" title="0">{
                        // Just show suggestions
                        fmt.Printf("Suggested clone locations for %s:\n", normalizedRepo)
                        for i, suggestion := range suggestions </span><span class="cov0" title="0">{
                                fmt.Printf("%d. %s (similarity: %d)\n", i+1, suggestion.Path, suggestion.Score)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                
                // Use the best suggestion or ask user
                <span class="cov0" title="0">var targetPath string
                if cloneTarget != "" </span><span class="cov0" title="0">{
                        targetPath = cloneTarget
                }</span> else<span class="cov0" title="0"> if len(suggestions) &gt; 0 </span><span class="cov0" title="0">{
                        targetPath = suggestions[0].Path
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to default location
                        targetPath = filepath.Join(os.Getenv("HOME"), "projects", filepath.Base(normalizedRepo))
                }</span>
                
                // Clone the repository
                <span class="cov0" title="0">cloneRepo(normalizedRepo, targetPath)</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(cloneCmd)
        cloneCmd.Flags().StringVar(&amp;cloneTarget, "target", "", "Specific target directory for cloning")
        cloneCmd.Flags().BoolVar(&amp;cloneSuggest, "suggest", false, "Only suggest clone locations, don't actually clone")
}</span>

// CloneSuggestion represents a suggested clone location
type CloneSuggestion struct {
        Path   string
        Score  int
        Reason string
}

// normalizeRepoURL normalizes repository URLs to org/repo format
func normalizeRepoURL(repo string) string <span class="cov0" title="0">{
        // Handle full GitHub URLs
        if strings.HasPrefix(repo, "https://github.com/") </span><span class="cov0" title="0">{
                parts := strings.Split(repo, "/")
                if len(parts) &gt;= 5 </span><span class="cov0" title="0">{
                        org := parts[3]
                        repoName := strings.TrimSuffix(parts[4], ".git")
                        return org + "/" + repoName
                }</span>
        }
        
        // Handle git@github.com: format
        <span class="cov0" title="0">if strings.HasPrefix(repo, "git@github.com:") </span><span class="cov0" title="0">{
                parts := strings.Split(repo, ":")
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        orgRepo := strings.TrimSuffix(parts[1], ".git")
                        return orgRepo
                }</span>
        }
        
        // Handle org/repo format
        <span class="cov0" title="0">if strings.Contains(repo, "/") &amp;&amp; !strings.Contains(repo, "://") </span><span class="cov0" title="0">{
                return repo
        }</span>
        
        <span class="cov0" title="0">return ""</span>
}

// getExistingProjects gets existing projects from cache
func getExistingProjects() []Project <span class="cov0" title="0">{
        c := cache.New()
        var cachedDirs []ProjectDir
        
        if !c.Get("project-dirs", &amp;cachedDirs) </span><span class="cov0" title="0">{
                return []Project{}
        }</span>
        
        <span class="cov0" title="0">var projects []Project
        for _, dir := range cachedDirs </span><span class="cov0" title="0">{
                dirProjects := findGitProjects([]string{dir.Path})
                projects = append(projects, dirProjects...)
        }</span>
        
        <span class="cov0" title="0">return projects</span>
}

// suggestCloneLocation suggests optimal clone locations based on similarity
func suggestCloneLocation(repo string, existingProjects []Project) []CloneSuggestion <span class="cov0" title="0">{
        orgRepo := strings.Split(repo, "/")
        if len(orgRepo) != 2 </span><span class="cov0" title="0">{
                return []CloneSuggestion{}
        }</span>
        
        <span class="cov0" title="0">org := orgRepo[0]
        repoName := orgRepo[1]
        
        var suggestions []CloneSuggestion
        
        // Analyze existing project structure
        orgPaths := make(map[string]int)
        similarRepos := make(map[string]int)
        
        for _, project := range existingProjects </span><span class="cov0" title="0">{
                projectPath := project.Path
                projectDir := filepath.Dir(projectPath)
                projectName := filepath.Base(projectPath)
                
                // Count org-based directories
                if strings.Contains(projectDir, org) </span><span class="cov0" title="0">{
                        orgPaths[projectDir]++
                }</span>
                
                // Find similar repository names
                <span class="cov0" title="0">similarity := levenshteinDistance(strings.ToLower(repoName), strings.ToLower(projectName))
                if similarity &lt; 5 </span><span class="cov0" title="0">{ // Threshold for similarity
                        similarRepos[projectDir] = similarity
                }</span>
        }
        
        // Generate suggestions based on analysis
        <span class="cov0" title="0">home := os.Getenv("HOME")
        
        // Suggestion 1: Existing org directory
        for orgPath, count := range orgPaths </span><span class="cov0" title="0">{
                suggestions = append(suggestions, CloneSuggestion{
                        Path:   filepath.Join(orgPath, repoName),
                        Score:  count * 10, // Higher score for more projects in this org
                        Reason: fmt.Sprintf("Existing %s directory (%d projects)", org, count),
                })
        }</span>
        
        // Suggestion 2: Similar repository locations
        <span class="cov0" title="0">for similarPath, similarity := range similarRepos </span><span class="cov0" title="0">{
                suggestions = append(suggestions, CloneSuggestion{
                        Path:   filepath.Join(similarPath, repoName),
                        Score:  20 - similarity, // Lower similarity = higher score
                        Reason: fmt.Sprintf("Similar repository location (distance: %d)", similarity),
                })
        }</span>
        
        // Suggestion 3: Default org-based location
        <span class="cov0" title="0">defaultOrgPath := filepath.Join(home, "projects", org)
        suggestions = append(suggestions, CloneSuggestion{
                Path:   filepath.Join(defaultOrgPath, repoName),
                Score:  5,
                Reason: fmt.Sprintf("Default %s organization directory", org),
        })
        
        // Suggestion 4: Default projects location
        defaultPath := filepath.Join(home, "projects", repoName)
        suggestions = append(suggestions, CloneSuggestion{
                Path:   defaultPath,
                Score:  1,
                Reason: "Default projects directory",
        })
        
        // Sort by score (highest first)
        sort.Slice(suggestions, func(i, j int) bool </span><span class="cov0" title="0">{
                return suggestions[i].Score &gt; suggestions[j].Score
        }</span>)
        
        // Remove duplicates
        <span class="cov0" title="0">seen := make(map[string]bool)
        var unique []CloneSuggestion
        for _, suggestion := range suggestions </span><span class="cov0" title="0">{
                if !seen[suggestion.Path] </span><span class="cov0" title="0">{
                        seen[suggestion.Path] = true
                        unique = append(unique, suggestion)
                }</span>
        }
        
        <span class="cov0" title="0">return unique</span>
}

// cloneRepo clones the repository to the target path
func cloneRepo(repo, targetPath string) <span class="cov0" title="0">{
        // Ensure parent directory exists
        parentDir := filepath.Dir(targetPath)
        if err := os.MkdirAll(parentDir, 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating directory %s: %v\n", parentDir, err)
                return
        }</span>
        
        // Clone the repository
        <span class="cov0" title="0">cloneURL := "https://github.com/" + repo + ".git"
        fmt.Printf("Cloning %s to %s...\n", cloneURL, targetPath)
        
        // Use git clone command
        cmd := fmt.Sprintf("git clone %s %s", cloneURL, targetPath)
        fmt.Printf("Running: %s\n", cmd)
        
        // Note: In a real implementation, you'd use os/exec to run the git command
        // For now, just show what would be executed
        fmt.Printf("Repository would be cloned to: %s\n", targetPath)
        fmt.Printf("After cloning, run: gum dirs-cache --refresh\n")</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/
package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/shalomb/gum/internal/cache"
        "github.com/spf13/cobra"
)

// ProjectDir represents a project directory entry
type ProjectDir struct {
        Path        string    `json:"path"`
        LastScanned time.Time `json:"last_scanned"`
        GitCount    int       `json:"git_count"`
}

var (
        dirsCacheRefresh bool
        dirsCacheClear   bool
        dirsCacheList    bool
)

// dirsCacheCmd represents the dirs-cache command
var dirsCacheCmd = &amp;cobra.Command{
        Use:   "dirs-cache",
        Short: "Manage project directories cache",
        Long: `Manage the cache of project directories that gum scans for Git repositories.

This command allows you to:
- List currently cached project directories
- Refresh the cache by auto-discovering directories
- Clear the cache to force re-discovery

Auto-discovery looks for:
- ~/projects/ (default)
- ~/projects-* (glob pattern)
- Any directories in ~/.config/projects-dirs.list (legacy support)`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                c := cache.New()
                
                if dirsCacheClear </span><span class="cov0" title="0">{
                        if err := c.Clear("project-dirs"); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error clearing cache: %v\n", err)
                                return
                        }</span>
                        <span class="cov0" title="0">fmt.Println("Project directories cache cleared")
                        return</span>
                }
                
                <span class="cov0" title="0">if dirsCacheList </span><span class="cov0" title="0">{
                        var dirs []ProjectDir
                        if c.Get("project-dirs", &amp;dirs) </span><span class="cov0" title="0">{
                                fmt.Println("Cached project directories:")
                                for _, dir := range dirs </span><span class="cov0" title="0">{
                                        fmt.Printf("  %s (last scanned: %s, %d git repos)\n", 
                                                dir.Path, dir.LastScanned.Format("2006-01-02 15:04:05"), dir.GitCount)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Println("No cached project directories found")
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                
                <span class="cov0" title="0">if dirsCacheRefresh </span><span class="cov0" title="0">{
                        dirs := discoverProjectDirs()
                        if err := c.Set("project-dirs", dirs, cache.ProjectDirsCacheTTL); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error updating cache: %v\n", err)
                                return
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("Discovered %d project directories and cached them\n", len(dirs))
                        for _, dir := range dirs </span><span class="cov0" title="0">{
                                fmt.Printf("  %s (%d git repos)\n", dir.Path, dir.GitCount)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                
                // Default: show status
                <span class="cov0" title="0">var dirs []ProjectDir
                if c.Get("project-dirs", &amp;dirs) </span><span class="cov0" title="0">{
                        fmt.Printf("Project directories cache is valid (%d directories)\n", len(dirs))
                        fmt.Println("Use --list to see details, --refresh to update, --clear to reset")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("No project directories cache found")
                        fmt.Println("Use --refresh to discover and cache project directories")
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(dirsCacheCmd)
        dirsCacheCmd.Flags().BoolVar(&amp;dirsCacheRefresh, "refresh", false, "Refresh the cache by discovering directories")
        dirsCacheCmd.Flags().BoolVar(&amp;dirsCacheClear, "clear", false, "Clear the project directories cache")
        dirsCacheCmd.Flags().BoolVar(&amp;dirsCacheList, "list", false, "List cached project directories")
}</span>

// discoverProjectDirs finds all project directories
func discoverProjectDirs() []ProjectDir <span class="cov0" title="0">{
        home := os.Getenv("HOME")
        var dirs []ProjectDir
        
        // Add default directories
        defaultDirs := []string{
                filepath.Join(home, "projects"),
                filepath.Join(home, "oneTakeda"),
        }
        
        // Add ~/projects-* directories
        projectsPattern := filepath.Join(home, "projects-*")
        if matches, err := filepath.Glob(projectsPattern); err == nil </span><span class="cov0" title="0">{
                for _, match := range matches </span><span class="cov0" title="0">{
                        if stat, err := os.Stat(match); err == nil &amp;&amp; stat.IsDir() </span><span class="cov0" title="0">{
                                defaultDirs = append(defaultDirs, match)
                        }</span>
                }
        }
        
        // Add directories from legacy projects-dirs.list
        <span class="cov0" title="0">configDir := os.Getenv("XDG_CONFIG_HOME")
        if configDir == "" </span><span class="cov0" title="0">{
                configDir = filepath.Join(home, ".config")
        }</span>
        
        <span class="cov0" title="0">projectsDirsList := filepath.Join(configDir, "projects-dirs.list")
        if data, err := os.ReadFile(projectsDirsList); err == nil </span><span class="cov0" title="0">{
                lines := strings.Split(string(data), "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        line = strings.TrimSpace(line)
                        if line != "" &amp;&amp; !strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                                // Expand ~ to home directory
                                if strings.HasPrefix(line, "~/") </span><span class="cov0" title="0">{
                                        line = filepath.Join(home, line[2:])
                                }</span>
                                <span class="cov0" title="0">defaultDirs = append(defaultDirs, line)</span>
                        }
                }
        }
        
        // Remove duplicates and count git repos
        <span class="cov0" title="0">seen := make(map[string]bool)
        for _, dir := range defaultDirs </span><span class="cov0" title="0">{
                if !seen[dir] &amp;&amp; dirExists(dir) </span><span class="cov0" title="0">{
                        seen[dir] = true
                        gitCount := countGitRepos(dir)
                        dirs = append(dirs, ProjectDir{
                                Path:        dir,
                                LastScanned: time.Now(),
                                GitCount:    gitCount,
                        })
                }</span>
        }
        
        <span class="cov0" title="0">return dirs</span>
}

// dirExists checks if a directory exists
func dirExists(path string) bool <span class="cov0" title="0">{
        stat, err := os.Stat(path)
        return err == nil &amp;&amp; stat.IsDir()
}</span>

// countGitRepos counts .git directories in a path
func countGitRepos(path string) int <span class="cov0" title="0">{
        count := 0
        filepath.Walk(path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip errors
                }</span>
                <span class="cov0" title="0">if info.IsDir() &amp;&amp; info.Name() == ".git" </span><span class="cov0" title="0">{
                        count++
                        return filepath.SkipDir // Don't recurse into .git
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return count</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/
package cmd

import (
        "fmt"
        "os"
        "sort"
        "strings"
        "time"

        ps "github.com/mitchellh/go-ps"
        log "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/shalomb/gum/internal/cache"
)

// dirsCmd represents the dirs command
var dirsCmd = &amp;cobra.Command{
        Use:   "dirs",
        Short: "List frequently accessed directories",
        Long: `Track and list frequently accessed directories based on running processes.
This replaces the shell script cwds-list with better performance and Go-native implementation.`,

        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                format, _ := cmd.Flags().GetString("format")
                verbose, _ := cmd.Flags().GetBool("verbose")
                refresh, _ := cmd.Flags().GetBool("refresh")
                clearCache, _ := cmd.Flags().GetBool("clear-cache")
                
                if clearCache </span><span class="cov0" title="0">{
                        c := cache.New()
                        if err := c.Clear("dirs"); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error clearing cache: %v\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">fmt.Println("Dirs cache cleared")
                        return</span>
                }
                
                <span class="cov0" title="0">doUpdateDirs(format, verbose, refresh)</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(dirsCmd)

        // Add flags for different output formats
        dirsCmd.Flags().StringP("format", "f", "default", "Output format: default, fzf, json, simple")
        dirsCmd.Flags().BoolP("verbose", "v", false, "Show verbose output with scores")
        dirsCmd.Flags().BoolP("refresh", "r", false, "Force refresh cache")
        dirsCmd.Flags().BoolP("clear-cache", "", false, "Clear cache and exit")
}</span>

type DirEntry struct {
        Path      string
        Score     int64
        Frequency int
        LastSeen  time.Time
}

func doUpdateDirs(format string, verbose bool, refresh bool) <span class="cov0" title="0">{
        c := cache.New()
        var entries []*DirEntry
        
        // Try to get from cache first (unless refresh is requested)
        if !refresh </span><span class="cov0" title="0">{
                if c.Get("dirs", &amp;entries) </span>{<span class="cov0" title="0">
                        // Cache hit - use cached data
                }</span> else<span class="cov0" title="0"> {
                        // Cache miss - fetch fresh data
                        entries = fetchDirs()
                        c.Set("dirs", entries, cache.DirsCacheTTL)
                }</span>
        } else<span class="cov0" title="0"> {
                // Force refresh - fetch fresh data
                entries = fetchDirs()
                c.Set("dirs", entries, cache.DirsCacheTTL)
        }</span>

        // Sort by score (highest first)
        <span class="cov0" title="0">sort.Slice(entries, func(i, j int) bool </span><span class="cov0" title="0">{
                return entries[i].Score &gt; entries[j].Score
        }</span>)

        // Output based on format
        <span class="cov0" title="0">switch format </span>{
        case "fzf":<span class="cov0" title="0">
                outputFzfFormat(entries, verbose)</span>
        case "json":<span class="cov0" title="0">
                outputJsonFormat(entries)</span>
        case "simple":<span class="cov0" title="0">
                outputSimpleFormat(entries)</span>
        default:<span class="cov0" title="0">
                outputDefaultFormat(entries, verbose)</span>
        }
}

func fetchDirs() []*DirEntry <span class="cov0" title="0">{
        pslist, err := ps.Processes()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error listing processes: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">dirs := make(map[string]*DirEntry)
        now := time.Now()

        for _, pid := range pslist </span><span class="cov0" title="0">{
                cwd := fmt.Sprintf("/proc/%d/cwd", pid.Pid())
                dir, err := os.Readlink(cwd)
                if err != nil || len(dir) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Filter to home directory only
                <span class="cov0" title="0">home := os.Getenv("HOME")
                if !strings.HasPrefix(dir, home) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Convert to ~ notation
                <span class="cov0" title="0">displayPath := "~" + dir[len(home):]

                if entry, exists := dirs[displayPath]; exists </span><span class="cov0" title="0">{
                        entry.Frequency++
                        entry.LastSeen = now
                        // Update score with recency weighting
                        entry.Score = calculateScore(entry.Frequency, entry.LastSeen, now)
                }</span> else<span class="cov0" title="0"> {
                        dirs[displayPath] = &amp;DirEntry{
                                Path:      displayPath,
                                Score:     1,
                                Frequency: 1,
                                LastSeen:  now,
                        }
                }</span>
        }

        // Convert to slice
        <span class="cov0" title="0">var entries []*DirEntry
        for _, entry := range dirs </span><span class="cov0" title="0">{
                entries = append(entries, entry)
        }</span>

        <span class="cov0" title="0">return entries</span>
}

func calculateScore(frequency int, lastSeen, now time.Time) int64 <span class="cov0" title="0">{
        // Simple scoring: frequency * recency factor
        hoursAgo := now.Sub(lastSeen).Hours()
        recencyFactor := 1.0 / (1.0 + hoursAgo/24.0) // Decay over days
        return int64(float64(frequency) * recencyFactor * 1000)
}</span>

func outputDefaultFormat(entries []*DirEntry, verbose bool) <span class="cov0" title="0">{
        for _, entry := range entries </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("%d\t%s\n", entry.Score, entry.Path)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%s\n", entry.Path)
                }</span>
        }
}

func outputFzfFormat(entries []*DirEntry, verbose bool) <span class="cov0" title="0">{
        for _, entry := range entries </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        // Format for fzf with visual indicators
                        fmt.Printf("%-50s %-15s %d processes\n", 
                                entry.Path, "[frequent]", entry.Frequency)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%s\n", entry.Path)
                }</span>
        }
}

func outputSimpleFormat(entries []*DirEntry) <span class="cov0" title="0">{
        for _, entry := range entries </span><span class="cov0" title="0">{
                fmt.Printf("%s\n", entry.Path)
        }</span>
}

func outputJsonFormat(entries []*DirEntry) <span class="cov0" title="0">{
        fmt.Printf("[\n")
        for i, entry := range entries </span><span class="cov0" title="0">{
                fmt.Printf("  {\n")
                fmt.Printf("    \"path\": \"%s\",\n", entry.Path)
                fmt.Printf("    \"score\": %d,\n", entry.Score)
                fmt.Printf("    \"frequency\": %d,\n", entry.Frequency)
                fmt.Printf("    \"last_seen\": \"%s\"\n", entry.LastSeen.Format(time.RFC3339))
                if i &lt; len(entries)-1 </span><span class="cov0" title="0">{
                        fmt.Printf("  },\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  }\n")
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("]\n")</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/
package cmd

import (
        "encoding/json"
        "fmt"
        "os/exec"
        "sort"
        "strings"
        "time"

        "github.com/spf13/cobra"
        "github.com/shalomb/gum/internal/cache"
)

// GitHubRepo represents a GitHub repository
type GitHubRepo struct {
        Name        string `json:"name"`
        FullName    string `json:"nameWithOwner"`
        Description string `json:"description"`
        URL         string `json:"url"`
        CloneURL    string `json:"sshUrl"`
        UpdatedAt   string `json:"updatedAt"`
        Private     bool   `json:"isPrivate"`
        Fork        bool   `json:"isFork"`
}

// GitHubDiscovery represents cached GitHub discovery data
type GitHubDiscovery struct {
        Repos      []GitHubRepo `json:"repos"`
        LastUpdate time.Time    `json:"last_update"`
        User       string       `json:"user"`
}

var (
        githubRefresh bool
        githubClear   bool
        githubList    bool
)

// githubCmd represents the github command
var githubCmd = &amp;cobra.Command{
        Use:   "github",
        Short: "Discover and manage GitHub repositories",
        Long: `Discover GitHub repositories visible to the current user using the GitHub CLI.

This command:
- Discovers repositories from the current user and organizations
- Caches results for performance (12-hour TTL)
- Provides similarity matching for repository discovery
- Updates twice daily via cron job

The discovery includes:
- User's own repositories
- Organization repositories the user has access to
- Both public and private repositories`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                c := cache.New()
                
                if githubClear </span><span class="cov0" title="0">{
                        if err := c.Clear("github-repos"); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error clearing cache: %v\n", err)
                                return
                        }</span>
                        <span class="cov0" title="0">fmt.Println("GitHub repositories cache cleared")
                        return</span>
                }
                
                <span class="cov0" title="0">if githubList </span><span class="cov0" title="0">{
                        var discovery GitHubDiscovery
                        if c.Get("github-repos", &amp;discovery) </span><span class="cov0" title="0">{
                                fmt.Printf("Cached GitHub repositories (%d total, last updated: %s):\n", 
                                        len(discovery.Repos), discovery.LastUpdate.Format("2006-01-02 15:04:05"))
                                for _, repo := range discovery.Repos </span><span class="cov0" title="0">{
                                        visibility := "public"
                                        if repo.Private </span><span class="cov0" title="0">{
                                                visibility = "private"
                                        }</span>
                                        <span class="cov0" title="0">fmt.Printf("  %s (%s) - %s\n", repo.FullName, visibility, repo.Description)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                fmt.Println("No cached GitHub repositories found")
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                
                <span class="cov0" title="0">if githubRefresh </span><span class="cov0" title="0">{
                        repos := discoverGitHubRepos()
                        if len(repos) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No GitHub repositories found or gh CLI not authenticated")
                                return
                        }</span>
                        
                        <span class="cov0" title="0">discovery := GitHubDiscovery{
                                Repos:      repos,
                                LastUpdate: time.Now(),
                                User:       getCurrentUser(),
                        }
                        
                        if err := c.Set("github-repos", discovery, 12*time.Hour); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error updating cache: %v\n", err)
                                return
                        }</span>
                        
                        <span class="cov0" title="0">fmt.Printf("Discovered %d GitHub repositories and cached them\n", len(repos))
                        for _, repo := range repos[:min(5, len(repos))] </span><span class="cov0" title="0">{
                                fmt.Printf("  %s - %s\n", repo.FullName, repo.Description)
                        }</span>
                        <span class="cov0" title="0">if len(repos) &gt; 5 </span><span class="cov0" title="0">{
                                fmt.Printf("  ... and %d more\n", len(repos)-5)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                
                // Default: show status
                <span class="cov0" title="0">var discovery GitHubDiscovery
                if c.Get("github-repos", &amp;discovery) </span><span class="cov0" title="0">{
                        fmt.Printf("GitHub repositories cache is valid (%d repositories, user: %s)\n", 
                                len(discovery.Repos), discovery.User)
                        fmt.Println("Use --list to see details, --refresh to update, --clear to reset")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("No GitHub repositories cache found")
                        fmt.Println("Use --refresh to discover GitHub repositories")
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(githubCmd)
        githubCmd.Flags().BoolVar(&amp;githubRefresh, "refresh", false, "Refresh the cache by discovering repositories")
        githubCmd.Flags().BoolVar(&amp;githubClear, "clear", false, "Clear the GitHub repositories cache")
        githubCmd.Flags().BoolVar(&amp;githubList, "list", false, "List cached GitHub repositories")
}</span>

// discoverGitHubRepos discovers repositories using gh CLI
func discoverGitHubRepos() []GitHubRepo <span class="cov0" title="0">{
        // Get user's repositories
        userRepos := getReposFromGh("repo list --json name,nameWithOwner,description,url,sshUrl,updatedAt,isPrivate,isFork --limit 100")
        
        // Get organization repositories
        orgRepos := getReposFromGh("repo list --json name,nameWithOwner,description,url,sshUrl,updatedAt,isPrivate,isFork --limit 100 --source")
        
        // Combine and deduplicate
        allRepos := append(userRepos, orgRepos...)
        uniqueRepos := deduplicateRepos(allRepos)
        
        // Sort by update time (most recent first)
        sort.Slice(uniqueRepos, func(i, j int) bool </span><span class="cov0" title="0">{
                timeI, _ := time.Parse(time.RFC3339, uniqueRepos[i].UpdatedAt)
                timeJ, _ := time.Parse(time.RFC3339, uniqueRepos[j].UpdatedAt)
                return timeI.After(timeJ)
        }</span>)
        
        <span class="cov0" title="0">return uniqueRepos</span>
}

// getReposFromGh executes gh command and parses JSON output
func getReposFromGh(command string) []GitHubRepo <span class="cov0" title="0">{
        cmd := exec.Command("gh", strings.Fields(command)...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return []GitHubRepo{}
        }</span>
        
        <span class="cov0" title="0">var repos []GitHubRepo
        if err := json.Unmarshal(output, &amp;repos); err != nil </span><span class="cov0" title="0">{
                return []GitHubRepo{}
        }</span>
        
        <span class="cov0" title="0">return repos</span>
}

// deduplicateRepos removes duplicate repositories
func deduplicateRepos(repos []GitHubRepo) []GitHubRepo <span class="cov0" title="0">{
        seen := make(map[string]bool)
        var unique []GitHubRepo
        
        for _, repo := range repos </span><span class="cov0" title="0">{
                if !seen[repo.FullName] </span><span class="cov0" title="0">{
                        seen[repo.FullName] = true
                        unique = append(unique, repo)
                }</span>
        }
        
        <span class="cov0" title="0">return unique</span>
}

// getCurrentUser gets the current GitHub user
func getCurrentUser() string <span class="cov0" title="0">{
        cmd := exec.Command("gh", "api", "user", "--jq", ".login")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/
package cmd

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"

        "github.com/spf13/cobra"
        "github.com/shalomb/gum/internal/cache"
)

// projectsCmd represents the projects command
var projectsCmd = &amp;cobra.Command{
        Use:   "projects",
        Short: "List Git projects from configured directories",
        Long: `Scan configured directories for Git repositories and list them with their
remote URLs or current branch information. This replaces the shell script
projects-list with better performance and Go-native implementation.`,

        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                format, _ := cmd.Flags().GetString("format")
                refresh, _ := cmd.Flags().GetBool("refresh")
                clearCache, _ := cmd.Flags().GetBool("clear-cache")
                
                if clearCache </span><span class="cov0" title="0">{
                        c := cache.New()
                        if err := c.Clear("projects"); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error clearing cache: %v\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">fmt.Println("Projects cache cleared")
                        return</span>
                }
                
                <span class="cov0" title="0">doListProjects(format, refresh)</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(projectsCmd)

        // Add flags for different output formats
        projectsCmd.Flags().StringP("format", "f", "default", "Output format: default, fzf, json, simple")
        projectsCmd.Flags().BoolP("refresh", "r", false, "Force refresh cache")
        projectsCmd.Flags().BoolP("clear-cache", "", false, "Clear cache and exit")
}</span>

type Project struct {
        Path   string
        Remote string
        Branch string
}

func doListProjects(format string, refresh bool) <span class="cov8" title="1">{
        c := cache.New()
        var projects []Project
        
        // Try to get from cache first (unless refresh is requested)
        if !refresh </span><span class="cov8" title="1">{
                if c.Get("projects", &amp;projects) </span>{<span class="cov8" title="1">
                        // Cache hit - use cached data
                }</span> else<span class="cov0" title="0"> {
                        // Cache miss - fetch fresh data
                        projects = fetchProjects()
                        c.Set("projects", projects, cache.ProjectsCacheTTL)
                }</span>
        } else<span class="cov8" title="1"> {
                // Force refresh - fetch fresh data
                projects = fetchProjects()
                c.Set("projects", projects, cache.ProjectsCacheTTL)
        }</span>
        
        // Sort projects by path
        <span class="cov8" title="1">sort.Slice(projects, func(i, j int) bool </span><span class="cov8" title="1">{
                return projects[i].Path &lt; projects[j].Path
        }</span>)
        
        // Output based on format
        <span class="cov8" title="1">switch format </span>{
        case "fzf":<span class="cov8" title="1">
                outputProjectsFzfFormat(projects)</span>
        case "json":<span class="cov8" title="1">
                outputProjectsJsonFormat(projects)</span>
        case "simple":<span class="cov8" title="1">
                outputProjectsSimpleFormat(projects)</span>
        default:<span class="cov8" title="1">
                outputProjectsDefaultFormat(projects)</span>
        }
}

func fetchProjects() []Project <span class="cov8" title="1">{
        // Get project directories from config
        projectDirs := getProjectDirs()
        
        // Find all Git repositories
        return findGitProjects(projectDirs)
}</span>

func getProjectDirs() []string <span class="cov8" title="1">{
        c := cache.New()
        var cachedDirs []ProjectDir
        
        // Try to get from cache first
        if c.Get("project-dirs", &amp;cachedDirs) </span><span class="cov0" title="0">{
                var dirs []string
                for _, dir := range cachedDirs </span><span class="cov0" title="0">{
                        dirs = append(dirs, dir.Path)
                }</span>
                <span class="cov0" title="0">return dirs</span>
        }
        
        // Fallback to legacy discovery if cache is empty
        <span class="cov8" title="1">home := os.Getenv("HOME")
        var dirs []string
        
        // Add ~/projects
        dirs = append(dirs, filepath.Join(home, "projects"))
        
        // Add ~/projects-* directories
        projectsPattern := filepath.Join(home, "projects-*")
        if matches, err := filepath.Glob(projectsPattern); err == nil </span><span class="cov8" title="1">{
                for _, match := range matches </span><span class="cov8" title="1">{
                        if stat, err := os.Stat(match); err == nil &amp;&amp; stat.IsDir() </span><span class="cov8" title="1">{
                                dirs = append(dirs, match)
                        }</span>
                }
        }
        
        // Read from projects-dirs.list if it exists
        <span class="cov8" title="1">configDir := os.Getenv("XDG_CONFIG_HOME")
        if configDir == "" </span><span class="cov0" title="0">{
                configDir = filepath.Join(home, ".config")
        }</span>
        
        <span class="cov8" title="1">projectsDirsList := filepath.Join(configDir, "projects-dirs.list")
        if data, err := os.ReadFile(projectsDirsList); err == nil </span><span class="cov8" title="1">{
                lines := strings.Split(string(data), "\n")
                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)
                        if line != "" &amp;&amp; !strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                                // Expand ~ to home directory
                                if strings.HasPrefix(line, "~/") </span><span class="cov0" title="0">{
                                        line = filepath.Join(home, line[2:])
                                }</span>
                                <span class="cov0" title="0">dirs = append(dirs, line)</span>
                        }
                }
        }
        
        // Remove duplicates
        <span class="cov8" title="1">seen := make(map[string]bool)
        var uniqueDirs []string
        for _, dir := range dirs </span><span class="cov8" title="1">{
                if !seen[dir] </span><span class="cov8" title="1">{
                        seen[dir] = true
                        uniqueDirs = append(uniqueDirs, dir)
                }</span>
        }
        
        <span class="cov8" title="1">return uniqueDirs</span>
}

func findGitProjects(dirs []string) []Project <span class="cov8" title="1">{
        var projects []Project
        
        for _, dir := range dirs </span><span class="cov8" title="1">{
                if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Find all .git directories
                <span class="cov8" title="1">err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                return nil // Skip errors, continue walking
                        }</span>
                        
                        <span class="cov8" title="1">if info.IsDir() &amp;&amp; info.Name() == ".git" </span><span class="cov8" title="1">{
                                projectDir := filepath.Dir(path)
                                project := getProjectInfo(projectDir)
                                if project.Path != "" </span><span class="cov8" title="1">{
                                        projects = append(projects, project)
                                }</span>
                                <span class="cov8" title="1">return filepath.SkipDir</span> // Don't recurse into .git
                        }
                        
                        <span class="cov8" title="1">return nil</span>
                })
                
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
        }
        
        <span class="cov8" title="1">return projects</span>
}

func getProjectInfo(projectDir string) Project <span class="cov8" title="1">{
        // Convert absolute path to ~ notation
        home := os.Getenv("HOME")
        var displayPath string
        if strings.HasPrefix(projectDir, home) </span><span class="cov8" title="1">{
                displayPath = "~" + projectDir[len(home):]
        }</span> else<span class="cov8" title="1"> {
                displayPath = projectDir
        }</span>
        
        <span class="cov8" title="1">project := Project{Path: displayPath}
        
        // Get Git remote information
        if remotes := getGitRemotes(projectDir); len(remotes) &gt; 0 </span><span class="cov8" title="1">{
                project.Remote = remotes[0] // Use first remote
        }</span> else<span class="cov8" title="1"> {
                // No remotes, get current branch
                if branch := getCurrentBranch(projectDir); branch != "" </span><span class="cov8" title="1">{
                        project.Branch = branch
                }</span> else<span class="cov8" title="1"> {
                        project.Branch = "main" // Default branch
                }</span>
        }
        
        <span class="cov8" title="1">return project</span>
}

func getGitRemotes(projectDir string) []string <span class="cov8" title="1">{
        cmd := exec.Command("git", "remote", "-v")
        cmd.Dir = projectDir
        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov8" title="1">var remotes []string
        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                fields := strings.Fields(line)
                if len(fields) &gt;= 2 &amp;&amp; fields[2] == "(fetch)" </span><span class="cov8" title="1">{
                        remotes = append(remotes, fields[1])
                }</span>
        }
        
        <span class="cov8" title="1">return remotes</span>
}

func getCurrentBranch(projectDir string) string <span class="cov8" title="1">{
        cmd := exec.Command("git", "branch", "--show-current")
        cmd.Dir = projectDir
        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">return strings.TrimSpace(string(output))</span>
}

func outputProjectsDefaultFormat(projects []Project) <span class="cov8" title="1">{
        for _, project := range projects </span><span class="cov8" title="1">{
                if project.Remote != "" </span><span class="cov8" title="1">{
                        fmt.Printf("%s\t%s\n", project.Path, project.Remote)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("%s\t%s\n", project.Path, project.Branch)
                }</span>
        }
}

func outputProjectsFzfFormat(projects []Project) <span class="cov8" title="1">{
        // Count stats
        totalProjects := len(projects)
        withRemotes := 0
        withBranches := 0
        
        for _, project := range projects </span><span class="cov8" title="1">{
                if project.Remote != "" </span><span class="cov8" title="1">{
                        withRemotes++
                }</span> else<span class="cov8" title="1"> if project.Branch != "" </span><span class="cov8" title="1">{
                        withBranches++
                }</span>
        }
        
        // Get current working directory for similarity matching
        <span class="cov8" title="1">cwd, _ := os.Getwd()
        currentDir := filepath.Base(cwd)
        
        // Sort projects by similarity to current directory
        sortedProjects := sortProjectsBySimilarity(projects, currentDir)
        
        // Output projects
        for _, project := range sortedProjects </span><span class="cov8" title="1">{
                if project.Remote != "" </span><span class="cov8" title="1">{
                        fmt.Printf("%-60s %s\n", 
                                project.Path, project.Remote)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("%-60s %s\n", 
                                project.Path, project.Branch)
                }</span>
        }
        
        // Add stats separator and info
        <span class="cov8" title="1">fmt.Printf("\n")
        fmt.Printf("Stats: %d projects total | %d with remotes | %d local only\n", 
                totalProjects, withRemotes, withBranches)</span>
}

func outputProjectsSimpleFormat(projects []Project) <span class="cov8" title="1">{
        for _, project := range projects </span><span class="cov8" title="1">{
                fmt.Printf("%s\n", project.Path)
        }</span>
}

// sortProjectsBySimilarity sorts projects by similarity to current directory
func sortProjectsBySimilarity(projects []Project, currentDir string) []Project <span class="cov8" title="1">{
        // Create a copy to avoid modifying the original slice
        sorted := make([]Project, len(projects))
        copy(sorted, projects)
        
        // Sort by similarity score (lower distance = more similar)
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                scoreI := calculateSimilarityScore(sorted[i], currentDir)
                scoreJ := calculateSimilarityScore(sorted[j], currentDir)
                return scoreI &lt; scoreJ
        }</span>)
        
        <span class="cov8" title="1">return sorted</span>
}

// calculateSimilarityScore calculates similarity score between project and current directory
func calculateSimilarityScore(project Project, currentDir string) int <span class="cov8" title="1">{
        projectName := filepath.Base(project.Path)
        
        // Calculate Levenshtein distance
        distance := levenshteinDistance(strings.ToLower(currentDir), strings.ToLower(projectName))
        
        // Bonus for exact matches
        if strings.EqualFold(currentDir, projectName) </span><span class="cov8" title="1">{
                distance = 0
        }</span>
        
        // Bonus for partial matches
        <span class="cov8" title="1">if strings.Contains(strings.ToLower(projectName), strings.ToLower(currentDir)) </span><span class="cov8" title="1">{
                distance = distance / 2
        }</span>
        
        <span class="cov8" title="1">return distance</span>
}

// levenshteinDistance calculates the Levenshtein distance between two strings
func levenshteinDistance(s1, s2 string) int <span class="cov8" title="1">{
        r1, r2 := []rune(s1), []rune(s2)
        rows := len(r1) + 1
        cols := len(r2) + 1
        
        d := make([][]int, rows)
        for i := range d </span><span class="cov8" title="1">{
                d[i] = make([]int, cols)
        }</span>
        
        <span class="cov8" title="1">for i := 1; i &lt; rows; i++ </span><span class="cov8" title="1">{
                d[i][0] = i
        }</span>
        <span class="cov8" title="1">for j := 1; j &lt; cols; j++ </span><span class="cov8" title="1">{
                d[0][j] = j
        }</span>
        
        <span class="cov8" title="1">for i := 1; i &lt; rows; i++ </span><span class="cov8" title="1">{
                for j := 1; j &lt; cols; j++ </span><span class="cov8" title="1">{
                        cost := 0
                        if r1[i-1] != r2[j-1] </span><span class="cov8" title="1">{
                                cost = 1
                        }</span>
                        
                        <span class="cov8" title="1">d[i][j] = min3(
                                d[i-1][j]+1,      // deletion
                                d[i][j-1]+1,      // insertion
                                d[i-1][j-1]+cost, // substitution
                        )</span>
                }
        }
        
        <span class="cov8" title="1">return d[rows-1][cols-1]</span>
}

// min3 returns the minimum of three integers
func min3(a, b, c int) int <span class="cov8" title="1">{
        if a &lt; b &amp;&amp; a &lt; c </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">if b &lt; c </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return c</span>
}

func outputProjectsJsonFormat(projects []Project) <span class="cov8" title="1">{
        fmt.Printf("[\n")
        for i, project := range projects </span><span class="cov8" title="1">{
                fmt.Printf("  {\n")
                fmt.Printf("    \"path\": \"%s\",\n", project.Path)
                if project.Remote != "" </span><span class="cov8" title="1">{
                        fmt.Printf("    \"remote\": \"%s\",\n", project.Remote)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("    \"branch\": \"%s\",\n", project.Branch)
                }</span>
                <span class="cov8" title="1">if i &lt; len(projects)-1 </span><span class="cov8" title="1">{
                        fmt.Printf("  },\n")
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("  }\n")
                }</span>
        }
        <span class="cov8" title="1">fmt.Printf("]\n")</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">// Package cmd implements our commands
package cmd

/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/

import (
        "os"

        "github.com/spf13/cobra"
        // "github.com/spf13/viper"
)

var (
        // Debug Enable debugging
        Debug bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "gum",
        Short: "A brief description of your application",
        Long: `A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        // Uncomment the following line if your bare application
        // has an action associated with it:
        // Run: func(cmd *cobra.Command, args []string) { },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        // Here you will define your flags and configuration settings.
        // Cobra supports persistent flags, which, if defined here,
        // will be global for your application.

        // rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.gum.yaml)")

        // Cobra also supports local flags, which will only run
        // when this action is called directly.
        rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
        rootCmd.Flags().BoolP("clear-all-cache", "", false, "Clear all cache and exit")

  // rootCmd.PersistentFlags().BoolVarP(&amp;Debug, "debug", "d", false, "Display debugging output in the console. (default: false)")
        // viper.BindPFlag("debug", rootCmd.PersistentFlags().Lookup("debug"))
}</span>


</pre>
		
		<pre class="file" id="file6" style="display: none">// Package cmd implements our commands
package cmd

/*
Copyright Â© 2023 NAME HERE &lt;EMAIL ADDRESS&gt;
*/

import (
        "fmt"
        "os/exec"
        "os/user"
        "path/filepath"
        "strings"

        "github.com/adrg/xdg"
        log "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// updateCmd represents the update command
var updateCmd = &amp;cobra.Command{
        Use:   "update",
        Short: "Update the database",
        Long:  `Update the database`,

        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if err := doUpdate(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(updateCmd)

        // Here you will define your flags and configuration settings.

        // Cobra supports Persistent Flags which will work for this command
        // and all subcommands, e.g.:
        // updateCmd.PersistentFlags().String("foo", "", "A help for foo")

        // Cobra supports local flags which will only run when this command
        // is called directly, e.g.:
        updateCmd.Flags().BoolP("all", "a", true, "Update all targets (default)")
        updateCmd.Flags().BoolP("projects", "p", false, "Update projects")
        updateCmd.Flags().BoolP("dirs", "d", false, "Update dirs")

        viper.SetDefault("CacheDir", xdg.CacheHome)
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(filepath.Join(xdg.ConfigHome, "gum"))

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); ok </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("fatal: Missing config files: %T", err))</span>
                }
                <span class="cov0" title="0">panic(fmt.Errorf("fatal: Error reading in config: %T", err))</span>
        }
}

func doUpdate() error <span class="cov0" title="0">{
        fmt.Printf("doUpdate called")
        for key, value := range viper.GetViper().AllSettings() </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{
                        key: value,
                }).Info("\nCommand Flag")
        }</span>

        <span class="cov0" title="0">curUser, _ := user.Current()
        homeDir := curUser.HomeDir
        var result []string

        projectDirs := viper.GetStringSlice("projects")
        for _, dir := range projectDirs </span><span class="cov0" title="0">{
                if strings.HasPrefix(dir, "~/") </span><span class="cov0" title="0">{
                        target := filepath.Join(homeDir, dir[2:])
                        log.Printf("\nScanning directory: %v (%v)", target, dir)
                        cmd := exec.Command("find", "-L", target, "-iname", ".git", "-type", "d", "-prune")
                        stdout, err := cmd.Output()
                        if err != nil </span><span class="cov0" title="0">{
                                if exiterr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                                        if exiterr.ExitCode() == 1 </span><span class="cov0" title="0">{
                                                log.Printf("Exit status == 1: Ignoring")
                                        }</span> else<span class="cov0" title="0"> {
                                                log.Fatalf("error finding projects in %v: %v", target, err)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">for _, dir := range strings.Split(string(stdout), "\n") </span><span class="cov0" title="0">{
                                if len(dir) &gt; 0 </span><span class="cov0" title="0">{
                                        p := dir[:len(dir)-4]  // remove ".git" at the end
                                        // log.Printf("%v\n", p)
                                        result = append(result, strings.Replace(p, homeDir, "~", 1))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">fmt.Printf("%v", result)
        // return fmt.Errorf("Heh")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright Â© 2023 NAME HERE &lt;EMAIL ADDRESS&gt;

*/
package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

// versionCmd represents the version command
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "A brief description of your command",
        Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("version called")
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)

        // Here you will define your flags and configuration settings.

        // Cobra supports Persistent Flags which will work for this command
        // and all subcommands, e.g.:
        // versionCmd.PersistentFlags().String("foo", "", "A help for foo")

        // Cobra supports local flags which will only run when this command
        // is called directly, e.g.:
        // versionCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/
package cache

import (
        "encoding/json"
        "os"
        "path/filepath"
        "time"
)

// CacheEntry represents a cached item with metadata
type CacheEntry struct {
        Data      interface{} `json:"data"`
        Timestamp time.Time   `json:"timestamp"`
        TTL       time.Duration `json:"ttl"`
}

// Cache manages file-based caching for gum commands
type Cache struct {
        baseDir string
}

// New creates a new cache instance
func New() *Cache <span class="cov8" title="1">{
        cacheDir := getCacheDir()
        return &amp;Cache{
                baseDir: cacheDir,
        }
}</span>

// Get retrieves cached data if it exists and is not expired
func (c *Cache) Get(key string, target interface{}) bool <span class="cov8" title="1">{
        cacheFile := c.getCacheFile(key)
        
        data, err := os.ReadFile(cacheFile)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">var entry CacheEntry
        if err := json.Unmarshal(data, &amp;entry); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Check if cache is expired
        <span class="cov8" title="1">if time.Since(entry.Timestamp) &gt; entry.TTL </span><span class="cov8" title="1">{
                os.Remove(cacheFile) // Clean up expired cache
                return false
        }</span>
        
        // Unmarshal the actual data
        <span class="cov8" title="1">dataBytes, err := json.Marshal(entry.Data)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">if err := json.Unmarshal(dataBytes, target); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">return true</span>
}

// Set stores data in cache with TTL
func (c *Cache) Set(key string, data interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        entry := CacheEntry{
                Data:      data,
                Timestamp: time.Now(),
                TTL:       ttl,
        }
        
        // Ensure cache directory exists
        if err := os.MkdirAll(c.baseDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">cacheFile := c.getCacheFile(key)
        dataBytes, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">return os.WriteFile(cacheFile, dataBytes, 0644)</span>
}

// Clear removes a specific cache entry
func (c *Cache) Clear(key string) error <span class="cov8" title="1">{
        cacheFile := c.getCacheFile(key)
        return os.Remove(cacheFile)
}</span>

// ClearAll removes all cache entries
func (c *Cache) ClearAll() error <span class="cov8" title="1">{
        return os.RemoveAll(c.baseDir)
}</span>

// getCacheFile returns the full path to a cache file
func (c *Cache) getCacheFile(key string) string <span class="cov8" title="1">{
        return filepath.Join(c.baseDir, key+".json")
}</span>

// getCacheDir returns the cache directory path
func getCacheDir() string <span class="cov8" title="1">{
        cacheDir := os.Getenv("XDG_CACHE_HOME")
        if cacheDir == "" </span><span class="cov0" title="0">{
                cacheDir = filepath.Join(os.Getenv("HOME"), ".cache")
        }</span>
        <span class="cov8" title="1">return filepath.Join(cacheDir, "gum")</span>
}

// Default TTL values
const (
        ProjectsCacheTTL = 5 * time.Minute  // Projects change less frequently
        DirsCacheTTL     = 30 * time.Second // Directories change more frequently
        ProjectDirsCacheTTL = 1 * time.Hour // Project directories change rarely
)</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/
package database

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "time"

        _ "github.com/mattn/go-sqlite3"
)

// Database represents the gum SQLite database
type Database struct {
        db *sql.DB
}

// New creates a new database connection
func New() (*Database, error) <span class="cov8" title="1">{
        dbPath := getDatabasePath()
        
        // Ensure database directory exists
        if err := os.MkdirAll(filepath.Dir(dbPath), 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create database directory: %w", err)
        }</span>
        
        <span class="cov8" title="1">db, err := sql.Open("sqlite3", dbPath+"?_journal_mode=WAL&amp;_synchronous=NORMAL")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>
        
        // Enable foreign keys
        <span class="cov8" title="1">if _, err := db.Exec("PRAGMA foreign_keys = ON"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to enable foreign keys: %w", err)
        }</span>
        
        // Initialize schema
        <span class="cov8" title="1">if err := initSchema(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>
        
        <span class="cov8" title="1">return &amp;Database{db: db}, nil</span>
}

// Close closes the database connection
func (d *Database) Close() error <span class="cov8" title="1">{
        return d.db.Close()
}</span>

// getDatabasePath returns the path to the SQLite database file
func getDatabasePath() string <span class="cov8" title="1">{
        cacheDir := os.Getenv("XDG_CACHE_HOME")
        if cacheDir == "" </span><span class="cov0" title="0">{
                cacheDir = filepath.Join(os.Getenv("HOME"), ".cache")
        }</span>
        <span class="cov8" title="1">return filepath.Join(cacheDir, "gum", "gum.db")</span>
}

// initSchema initializes the database schema
func initSchema(db *sql.DB) error <span class="cov8" title="1">{
        schemaSQL := `
        -- Projects table: Git repositories found in project directories
        CREATE TABLE IF NOT EXISTS projects (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                path TEXT NOT NULL UNIQUE,
                name TEXT NOT NULL,
                remote_url TEXT,
                branch TEXT,
                last_modified DATETIME,
                git_count INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- Project directories table: Directories that contain projects
        CREATE TABLE IF NOT EXISTS project_dirs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                path TEXT NOT NULL UNIQUE,
                last_scanned DATETIME,
                git_count INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- GitHub repositories table: Repositories discovered via GitHub API
        CREATE TABLE IF NOT EXISTS github_repos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                full_name TEXT NOT NULL UNIQUE,
                description TEXT,
                url TEXT,
                clone_url TEXT,
                ssh_url TEXT,
                is_private BOOLEAN DEFAULT 0,
                is_fork BOOLEAN DEFAULT 0,
                updated_at DATETIME,
                last_discovered DATETIME DEFAULT CURRENT_TIMESTAMP,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- Directory usage tracking: For frecently used directories
        CREATE TABLE IF NOT EXISTS dir_usage (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                path TEXT NOT NULL,
                frequency INTEGER DEFAULT 1,
                last_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(path)
        );

        -- Similarity cache: Pre-computed similarity scores
        CREATE TABLE IF NOT EXISTS similarity_cache (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source_type TEXT NOT NULL,
                source_id INTEGER NOT NULL,
                target_type TEXT NOT NULL,
                target_id INTEGER NOT NULL,
                similarity_score REAL NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(source_type, source_id, target_type, target_id)
        );

        -- Indexes for performance
        CREATE INDEX IF NOT EXISTS idx_projects_path ON projects(path);
        CREATE INDEX IF NOT EXISTS idx_projects_name ON projects(name);
        CREATE INDEX IF NOT EXISTS idx_projects_remote ON projects(remote_url);
        CREATE INDEX IF NOT EXISTS idx_projects_updated ON projects(updated_at);

        CREATE INDEX IF NOT EXISTS idx_project_dirs_path ON project_dirs(path);
        CREATE INDEX IF NOT EXISTS idx_project_dirs_scanned ON project_dirs(last_scanned);

        CREATE INDEX IF NOT EXISTS idx_github_repos_full_name ON github_repos(full_name);
        CREATE INDEX IF NOT EXISTS idx_github_repos_name ON github_repos(name);
        CREATE INDEX IF NOT EXISTS idx_github_repos_updated ON github_repos(updated_at);
        CREATE INDEX IF NOT EXISTS idx_github_repos_private ON github_repos(is_private);

        CREATE INDEX IF NOT EXISTS idx_dir_usage_path ON dir_usage(path);
        CREATE INDEX IF NOT EXISTS idx_dir_usage_frequency ON dir_usage(frequency);
        CREATE INDEX IF NOT EXISTS idx_dir_usage_last_seen ON dir_usage(last_seen);

        CREATE INDEX IF NOT EXISTS idx_similarity_source ON similarity_cache(source_type, source_id);
        CREATE INDEX IF NOT EXISTS idx_similarity_target ON similarity_cache(target_type, target_id);
        CREATE INDEX IF NOT EXISTS idx_similarity_score ON similarity_cache(similarity_score);
        `
        
        _, err := db.Exec(schemaSQL)
        return err
}</span>

// Project represents a Git project
type Project struct {
        ID           int       `json:"id"`
        Path         string    `json:"path"`
        Name         string    `json:"name"`
        RemoteURL    string    `json:"remote_url"`
        Branch       string    `json:"branch"`
        LastModified time.Time `json:"last_modified"`
        GitCount     int       `json:"git_count"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

// ProjectDir represents a project directory
type ProjectDir struct {
        ID          int       `json:"id"`
        Path        string    `json:"path"`
        LastScanned time.Time `json:"last_scanned"`
        GitCount    int       `json:"git_count"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

// GitHubRepo represents a GitHub repository
type GitHubRepo struct {
        ID             int       `json:"id"`
        Name           string    `json:"name"`
        FullName       string    `json:"full_name"`
        Description    string    `json:"description"`
        URL            string    `json:"url"`
        CloneURL       string    `json:"clone_url"`
        SSHURL         string    `json:"ssh_url"`
        IsPrivate      bool      `json:"is_private"`
        IsFork         bool      `json:"is_fork"`
        UpdatedAt      time.Time `json:"updated_at"`
        LastDiscovered time.Time `json:"last_discovered"`
        CreatedAt      time.Time `json:"created_at"`
}

// DirUsage represents directory usage tracking
type DirUsage struct {
        ID        int       `json:"id"`
        Path      string    `json:"path"`
        Frequency int       `json:"frequency"`
        LastSeen  time.Time `json:"last_seen"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright Â© 2023 shalomb &lt;s.bhooshi@gmail.com&gt;
*/
package database

import (
        "fmt"
        "strings"
)

// Projects operations

// UpsertProject inserts or updates a project
func (d *Database) UpsertProject(project *Project) error <span class="cov8" title="1">{
        query := `
                INSERT INTO projects (path, name, remote_url, branch, last_modified, git_count)
                VALUES (?, ?, ?, ?, ?, ?)
                ON CONFLICT(path) DO UPDATE SET
                        name = excluded.name,
                        remote_url = excluded.remote_url,
                        branch = excluded.branch,
                        last_modified = excluded.last_modified,
                        git_count = excluded.git_count,
                        updated_at = CURRENT_TIMESTAMP
        `
        
        _, err := d.db.Exec(query, project.Path, project.Name, project.RemoteURL, 
                project.Branch, project.LastModified, project.GitCount)
        return err
}</span>

// GetProjects returns all projects, optionally sorted by similarity
func (d *Database) GetProjects(sortBySimilarity bool, targetPath string) ([]*Project, error) <span class="cov8" title="1">{
        var query string
        var args []interface{}
        
        if sortBySimilarity &amp;&amp; targetPath != "" </span><span class="cov0" title="0">{
                // Use similarity scoring with Levenshtein distance
                query = `
                        SELECT id, path, name, remote_url, branch, last_modified, git_count, created_at, updated_at
                        FROM projects
                        ORDER BY 
                                CASE 
                                        WHEN LOWER(name) = LOWER(?) THEN 0
                                        WHEN LOWER(name) LIKE '%' || LOWER(?) || '%' THEN 1
                                        ELSE 2
                                END,
                                updated_at DESC
                `
                args = []interface{}{targetPath, targetPath}
        }</span> else<span class="cov8" title="1"> {
                query = `
                        SELECT id, path, name, remote_url, branch, last_modified, git_count, created_at, updated_at
                        FROM projects
                        ORDER BY updated_at DESC
                `
        }</span>
        
        <span class="cov8" title="1">rows, err := d.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var projects []*Project
        for rows.Next() </span><span class="cov8" title="1">{
                var p Project
                err := rows.Scan(&amp;p.ID, &amp;p.Path, &amp;p.Name, &amp;p.RemoteURL, &amp;p.Branch, 
                        &amp;p.LastModified, &amp;p.GitCount, &amp;p.CreatedAt, &amp;p.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">projects = append(projects, &amp;p)</span>
        }
        
        <span class="cov8" title="1">return projects, nil</span>
}

// ProjectDirs operations

// UpsertProjectDir inserts or updates a project directory
func (d *Database) UpsertProjectDir(dir *ProjectDir) error <span class="cov8" title="1">{
        query := `
                INSERT INTO project_dirs (path, last_scanned, git_count)
                VALUES (?, ?, ?)
                ON CONFLICT(path) DO UPDATE SET
                        last_scanned = excluded.last_scanned,
                        git_count = excluded.git_count,
                        updated_at = CURRENT_TIMESTAMP
        `
        
        _, err := d.db.Exec(query, dir.Path, dir.LastScanned, dir.GitCount)
        return err
}</span>

// GetProjectDirs returns all project directories
func (d *Database) GetProjectDirs() ([]*ProjectDir, error) <span class="cov8" title="1">{
        query := `
                SELECT id, path, last_scanned, git_count, created_at, updated_at
                FROM project_dirs
                ORDER BY path
        `
        
        rows, err := d.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var dirs []*ProjectDir
        for rows.Next() </span><span class="cov8" title="1">{
                var d ProjectDir
                err := rows.Scan(&amp;d.ID, &amp;d.Path, &amp;d.LastScanned, &amp;d.GitCount, 
                        &amp;d.CreatedAt, &amp;d.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">dirs = append(dirs, &amp;d)</span>
        }
        
        <span class="cov8" title="1">return dirs, nil</span>
}

// GitHub repos operations

// UpsertGitHubRepo inserts or updates a GitHub repository
func (d *Database) UpsertGitHubRepo(repo *GitHubRepo) error <span class="cov8" title="1">{
        query := `
                INSERT INTO github_repos (name, full_name, description, url, clone_url, ssh_url, is_private, is_fork, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(full_name) DO UPDATE SET
                        name = excluded.name,
                        description = excluded.description,
                        url = excluded.url,
                        clone_url = excluded.clone_url,
                        ssh_url = excluded.ssh_url,
                        is_private = excluded.is_private,
                        is_fork = excluded.is_fork,
                        updated_at = excluded.updated_at,
                        last_discovered = CURRENT_TIMESTAMP
        `
        
        _, err := d.db.Exec(query, repo.Name, repo.FullName, repo.Description, 
                repo.URL, repo.CloneURL, repo.SSHURL, repo.IsPrivate, repo.IsFork, repo.UpdatedAt)
        return err
}</span>

// GetGitHubRepos returns all GitHub repositories
func (d *Database) GetGitHubRepos() ([]*GitHubRepo, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, full_name, description, url, clone_url, ssh_url, is_private, is_fork, updated_at, last_discovered, created_at
                FROM github_repos
                ORDER BY updated_at DESC
        `
        
        rows, err := d.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var repos []*GitHubRepo
        for rows.Next() </span><span class="cov8" title="1">{
                var r GitHubRepo
                err := rows.Scan(&amp;r.ID, &amp;r.Name, &amp;r.FullName, &amp;r.Description, 
                        &amp;r.URL, &amp;r.CloneURL, &amp;r.SSHURL, &amp;r.IsPrivate, &amp;r.IsFork, 
                        &amp;r.UpdatedAt, &amp;r.LastDiscovered, &amp;r.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">repos = append(repos, &amp;r)</span>
        }
        
        <span class="cov8" title="1">return repos, nil</span>
}

// DirUsage operations

// UpsertDirUsage inserts or updates directory usage tracking
func (d *Database) UpsertDirUsage(usage *DirUsage) error <span class="cov8" title="1">{
        query := `
                INSERT INTO dir_usage (path, frequency, last_seen)
                VALUES (?, ?, ?)
                ON CONFLICT(path) DO UPDATE SET
                        frequency = frequency + 1,
                        last_seen = excluded.last_seen,
                        updated_at = CURRENT_TIMESTAMP
        `
        
        _, err := d.db.Exec(query, usage.Path, usage.Frequency, usage.LastSeen)
        return err
}</span>

// GetFrequentDirs returns directories sorted by frequency and recency
func (d *Database) GetFrequentDirs(limit int) ([]*DirUsage, error) <span class="cov8" title="1">{
        query := `
                SELECT id, path, frequency, last_seen, created_at, updated_at
                FROM dir_usage
                ORDER BY 
                        frequency * (1.0 / (1.0 + (julianday('now') - julianday(last_seen)) / 1.0)) DESC,
                        last_seen DESC
                LIMIT ?
        `
        
        rows, err := d.db.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var dirs []*DirUsage
        for rows.Next() </span><span class="cov8" title="1">{
                var d DirUsage
                err := rows.Scan(&amp;d.ID, &amp;d.Path, &amp;d.Frequency, &amp;d.LastSeen, 
                        &amp;d.CreatedAt, &amp;d.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">dirs = append(dirs, &amp;d)</span>
        }
        
        <span class="cov8" title="1">return dirs, nil</span>
}

// Similarity operations

// GetSimilarProjects returns projects similar to the given path
func (d *Database) GetSimilarProjects(targetPath string, limit int) ([]*Project, error) <span class="cov8" title="1">{
        // Extract the target name for similarity matching
        targetName := targetPath
        if lastSlash := strings.LastIndex(targetPath, "/"); lastSlash != -1 </span><span class="cov0" title="0">{
                targetName = targetPath[lastSlash+1:]
        }</span>
        
        <span class="cov8" title="1">query := `
                SELECT id, path, name, remote_url, branch, last_modified, git_count, created_at, updated_at
                FROM projects
                WHERE 
                        LOWER(name) LIKE '%' || LOWER(?) || '%' OR
                        LOWER(path) LIKE '%' || LOWER(?) || '%'
                ORDER BY 
                        CASE 
                                WHEN LOWER(name) = LOWER(?) THEN 0
                                WHEN LOWER(name) LIKE '%' || LOWER(?) || '%' THEN 1
                                ELSE 2
                        END,
                        updated_at DESC
                LIMIT ?
        `
        
        rows, err := d.db.Query(query, targetName, targetName, targetName, targetName, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var projects []*Project
        for rows.Next() </span><span class="cov8" title="1">{
                var p Project
                err := rows.Scan(&amp;p.ID, &amp;p.Path, &amp;p.Name, &amp;p.RemoteURL, &amp;p.Branch, 
                        &amp;p.LastModified, &amp;p.GitCount, &amp;p.CreatedAt, &amp;p.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">projects = append(projects, &amp;p)</span>
        }
        
        <span class="cov8" title="1">return projects, nil</span>
}

// ClearCache clears all cached data
func (d *Database) ClearCache() error <span class="cov8" title="1">{
        tables := []string{"projects", "project_dirs", "github_repos", "dir_usage", "similarity_cache"}
        
        for _, table := range tables </span><span class="cov8" title="1">{
                _, err := d.db.Exec(fmt.Sprintf("DELETE FROM %s", table))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear table %s: %w", table, err)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// GetStats returns database statistics
func (d *Database) GetStats() (map[string]int, error) <span class="cov8" title="1">{
        stats := make(map[string]int)
        
        tables := []string{"projects", "project_dirs", "github_repos", "dir_usage"}
        
        for _, table := range tables </span><span class="cov8" title="1">{
                var count int
                err := d.db.QueryRow(fmt.Sprintf("SELECT COUNT(*) FROM %s", table)).Scan(&amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stats[table] = count</span>
        }
        
        <span class="cov8" title="1">return stats, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
